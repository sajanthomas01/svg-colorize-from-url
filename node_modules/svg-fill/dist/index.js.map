{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;AAAA,sDAA8B;AAC9B,kDAA0B;AAC1B,wDAAgC;AAUhC,SAAS,UAAU,CAAC,OAAgB;IAClC,IAAI,OAAO,GAAW,SAAS,CAAC;IAChC,OAAO,kBAAQ,CACb,UAAS,KAAK,EAAE,GAAG,EAAE,EAAE;QAErB,IAAI,OAAO,KAAK,SAAS,EAAE;YACzB,OAAO,GAAG,KAAK,CAAC;SACjB;aACI;YACH,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;SAC3C;QACD,EAAE,EAAE,CAAC;IACP,CAAC,EACD,UAAS,EAAE;QAET,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;QACpC,EAAE,EAAE,CAAC;IACP,CAAC,CACF,CAAC;AACJ,CAAC;AAED,MAAqB,OAAO;IAG1B,YAAY,SAAyB;QACnC,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;IAC/B,CAAC;IAED,YAAY,CAAC,SAAyB;QACpC,IAAI,CAAC,UAAU,GAAG,SAAS,YAAY,eAAK,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,eAAK,CAAC,SAAS,CAAC,CAAC;IAClF,CAAC;IAED,YAAY;QACV,OAAO,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAaD,OAAO,CAAC,OAAwB;QAG9B,MAAM,CAAC,GAAG,iBAAO,CAAC,IAAI,CAAC,OAAO,EAAE,EAAC,OAAO,EAAE,IAAI,EAAC,CAAC,CAAC;QACjD,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,YAAY,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;QACjD,OAAO,CAAC,CAAC,GAAG,EAAE,CAAC;IACjB,CAAC;IAaD,aAAa;QACX,OAAO,UAAU,CAAC,IAAI,CAAC,CAAC;IAC1B,CAAC;CACF;AAhDD,0BAgDC","sourcesContent":["import cheerio from 'cheerio';\nimport Color from 'color';\nimport through2 from 'through2';\nimport stream from 'stream';\n\n/**\n * Returns a transform stream that the SVG data can be\n * piped into. It will output the filled SVG data.\n *\n * @param svgFill   The SvgFill instance that will recolour\n *                   the streamed SVG data.\n */\nfunction makeStream(svgFill: SvgFill): stream.Transform {\n  let svgData: Buffer = undefined;\n  return through2(\n    function(chunk, enc, cb) {\n      // accumulate data\n      if (svgData === undefined) {\n        svgData = chunk;\n      }\n      else {\n        svgData = Buffer.concat([svgData, chunk]);\n      }\n      cb();\n    },\n    function(cb) {\n      // Now fill the SVG and push the result\n      this.push(svgFill.fillSvg(svgData));\n      cb();\n    }\n  );\n}\n\nexport default class SvgFill {\n  private _fillColor: Color;\n\n  constructor(fillColor: Color | string) {\n    this.setFillColor(fillColor);\n  }\n\n  setFillColor(fillColor: Color | string): void {\n    this._fillColor = fillColor instanceof Color ? fillColor : new Color(fillColor);\n  }\n\n  getFillColor(): Color {\n    return this._fillColor;\n  }\n\n  /**\n   * Fills all shapes in the SVG with the fill color.\n   *\n   * Note, this is currently a naive solution that simply adds a fill\n   * attribute with the chosen fill color to the SVG element. For SVGs\n   * without styling attributes, such as ones to be composed into\n   * a symbol sprite, this should work fine. For anything else, the\n   * results will be hit and miss.\n   *\n   * @param svgData A string or buffer containing valid SVG data.\n   */\n  fillSvg(svgData: Buffer | string): string {\n    // Forcing svgData to be \"string\" for TypeScript's benefit.\n    // In actual fact, cheerio.load() does accept Buffers too.\n    const $ = cheerio.load(svgData, {xmlMode: true});\n    $('svg').attr('fill', this.getFillColor().hex());\n    return $.xml();\n  }\n\n  /**\n   * Returns a transform stream that the SVG data can be\n   * piped into. It will output the filled SVG data.\n   *\n   * Note: This function is primarily for developer convenience.\n   * Internally, it waits until the entire SVG data has been received,\n   * before doing the transform and outputting it. Therefore, you\n   * don't really reap the benefits of streams, as any consumer will be\n   * stuck waiting until the full SVG data has been buffered and\n   * transformed.\n   */\n  fillSvgStream(): stream.Transform {\n    return makeStream(this);\n  }\n}\n"]}